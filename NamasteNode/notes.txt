********************************** Class 3 *************************************

================================== Class 3 =====================================


    1. node REPL - READ, EVALUATE, PRINT, LOOP 
    2. we can see that in terminal like cmd it is very similar to console in browsers but the differnce is instead of Node JS we have browser which is also running 
         V8 engine behind the scenes.
    3. Node JS is JS runtime environment.
    4. Inside Node JS we have V8 JS engine and some super powers and whenever we wrote any piece of JS code, Node JS gave/passed that code to V8 engine and then V8 engine 
         actually executed that code (as V8 engine written in C++ so it converts that code into machine level code so the computer can understand it).

-----------first code of node js------------ 
    5. we can just create a file with the name let say app.js write the code and run it by the command node (file name) in the terminal.
    6. in browser, window is the global object and this also points to the global object and it is given to us by browsers and over here in Node JS we have the global object
         and it is known as global.
    7. setTimeout, setInterval, setImmediate all are given to us by the global object.
    8. so global is not a part of V8 engine as global is outside and it is one of the super powers given by Node JS.
    9. and if we print this in node then it prints an Empty Object and it is not equal to the global object of browsers bcoz there window which is a global object and 
         this we pointing to the same object.
    10. Even if we write window(came when browsers created), this(started to pointing window object in the browsers), self(concept of web workers started self), frames all
          these differnet keywords refer to the same object.  as when node js came in they use the word global and there was a decripisensy as we using js so there has to
           be a common object.
    11. So then open js foundation, decided to make a standard global object in all the runtime environment and globalThis came which refer to all the js runtime environment
         (in all browsers).


================================== Class 4 =====================================


    1. In Node JS application, there is one entry point in the application.
    2. In real life projects, we have multiple files and we want them to execute like here we got app.js which is the entry point of application and another file xyz.js in 
         which there is js code that we want to execute and both the files are not related as they are sepearted files.
    3. xyz is a sepearte module.
    4. Two modules can work together by the require function and it will first print the file which is imported through require function and then the rest of the code.
    5. By default, Modules protects their variables and functions from leaking.
    6. So if we want to use variables or functions of one module to another we have to Explicitly export them.
    7. Whatever we will export through module.exports will be return from require function.
    8. The new file we create is known as a module, and if we run require, we can access the code of different modules. However, we can't access the variables and functions
        directly because modules don't leak them. If we want to use them, we have to export them, and require will return the variable, function, or object that we export.
    9. If we export one variable or function we can write: 
         
         - for exports (best practice to wrap everything in {} whether exporting one or multiple varible or function)
         module.exports = calculateSum; or module.exports = { calculateSum };   
         
         - for imports directly put the name of that varibale or function while importing it.
         const calculateSum =  require("./sum.js");


     10. If we export more than one variable or function we can write: 
         module.exports = {
          x: x,
          calculateSum: calculateSum};  or  module.exports = { x, calculateSum }; (best practice short hand in js)

     11. Other Modules have their own private space is a super power bcoz it protects the variable, as we can use same variable name in different modules unless we importing 
            them there like x in sum.js can do whatever they want to done but as app.js don't need to done anything with x we won't import it and can use the same varibale 
            x also.

     12. Two types of modules (IMPORT/EXPORT) :
     
          - Common JS Modules (CJS)
               - module.exports and require() 
               - by default used in Node JS
               - older way   
               - Synchronous     
               - non strict mode (can declare a variable without using var, let and const)
          
          - ES Modules (MJS / ESM / ES6 Modules)
               - import and export statements
               - by default used in React, Angular
               - newer way (better/standard way of export and import modules)
               - Asynchronous
               - strict mode (compulsory to declare a variable with var, let and const)

     13. Grouping together the same kind of files/ modules and making a single module (index.js) which helps in import and export of modules (FOLDER STRUCTURE).


================================== Class 5 =====================================

     1. Inside Node JS, there is V8 engine and Node JS gives our code to V8 JS engine and it executes our code.
     2. The whole module is wrapped inside a function and then executed and thats the reason why module keep variables and functions private and only way to access them
           outside by module.exports.
     3. Whenever we create a new module and call require function for the file then Node JS takes the code from the file, wraps it into a function and then execute it and 
         if there are any variables and functions which are there inside this function, we cannot directly access it outside as we can only access if module.exports 
         exported it outside.           
     4. When we call require("./path"), All the code of the nodule is wrapped inside a function, which is a special function which is known as IIFE.    
     5. IIFE - setImmediately Invoked Function Expression

          (function () {
               
               All code of the module runs inside here

          })()
     6. When we call require(), Node JS will take all the code and wrap inside an IIFE function and then it will give it to V8 JS engine.     
     7. Why need IIFE?
           - Immediately envokes the code
           - Privacy as it keeps variable and function safe/private
           - It won't interfare the code as it is independent now

           (function () {
               var a = 1000;
           })();t

           var a = 10;
     8. How are variable and function private in different module?
           - bcoz of IIFE and require(statement) as require statement is wrapping the code inside IIFE.

     9. How do you get access to module.exports?
           - When our code is wrapped inside a function, the function has parameters module and require given by Node JS.
           - Node JS passes module as a parameter to the IIFE in which the code is wrapped.
     10. Like there is a module xyz.js now Node JS will create a IIFE and our code will be passed inside IIFE and also Node JS pass module and require as prarameter and then
            it passed to V8 engine and V8 engine executes it and all the variables and function inside the module will not interfere with rest of the other code.

     11. 5 Step Mechanism of require("./PATH")
           - Resolving the Module
                  - It checks whether the module is a local path("./xyz.js") or JSON("./data.json") path or node internal module("node:util").
                  - It checks what type of data is coming whether it is coming from node module, json file or local path and accordingly it resolves the module.
           - Loading the module
                  - File content is loaded according to file type as it can be local, json or node module.
           - Wraps inside an IIFE (Compile)
           - Code Evaluation
                  - In this step, module.exports returns means when we require, it returns the exported variables or functions Whatever we exported. 
                  - Example:-  const {calculateMultiply, calculateSum } = require("./calculate");   
           - Caching (V.V.IMP)
                  - Then the module is cached.
                  - Multiple files requiring multiple modules
                  - xyz.js module require in different modules like multiple.js, sum.js and app.js now, Node caches the require, means the code of the require will only run once.
                  - As, it will not follow all 4 steps after executing once bcoz it is already cached and it will return from the cache.
     12. Libuv library most amazing super power node js has. Eventloop is inside libuv, multi-threading happens with libuv.




================================== Class 6 =====================================

     1. Node JS has an event-driven architecture capable of Asynchronous I/O.
     2. JS is a Synchronous single threaded language.



********************************** SEASON - 02 *************************************

================================== Class 01  =====================================

     1. Waterfall Model (SDLC)
           - REQUIREMENTS                                  
           => by PM - Product/Project Manager - What is Dev Tinder? What features, adueince, differnet scenario, how, tech stack. - PM with Designers
                
                - DESIGN                                   
                => Scenior Engineers/ EM - deciding the tech stack -  Monolith or MicroService architecture - System Design - High Level Design (HLD) - Low Level Design (LLD)
                     
                     - DEVELOPMENT                         
                     => SDE1 / SDE2 - writing Unit Test Cases
                          
                          - TESTING                        
                          =>  SDET - Software Development Engineer Testing - Automation, Manual Testing 
                               
                               - DEPLOYMENT                
                               => Devops Engineer - manages server, deploy - sometimes testers - mainly developers do deployment 
                                    
                                    - MAINTAINANCE         
                                    => Repeat Cycle - some new features or changes
     2. Monolith vs MicroServices
           - Monolith
                - One Big single project which does everything.
                - It has Backend, DB connection, Frontend, code to Authenticate, code to send Emails, code to analytics, Notification.
                - All code written in a single code repository or in a single project deployed on a single way.
           - MicroServices
                - There are multiple small services (Service/project/application ).
                - There can be a micro services only for Frontend or Backend or Authentication or Notification or Analytics or Admin or Creating Dashboard.
                - In large company, there are small small projects handled by different teams and communicating with each other.
                - For example: In uber, when we book a ride there are so many micro services which get active like a micro service which just calculate the fare, other micro
                  service just for Fraud Detection, other team handling just Notifications and other team handling just Invoices/Billings.                                                       
     3. Monolith vs MicroServices Comparison
          -----------------------------
           i. Dev Speed and Code Repo 
           -----------------------------
           In Monolith, there is a single code repository where all the developers are working like 20-30 developers. As, Single Code Repo so Dev Speed is slow bcoz lot of
           developers working on the same code repository, code reviews become slower, it becomes tough for execution also, developmemt Speed becomes slow as when we want 
           to run the application we have to compile the whole project. So, Dev speed comprised a little in Monolith.

           In MicroServices, some developers are working on one service, some other developers on another service. Multiple code repo are there. We can built parallel also as
           in Monolith we can do same but in MicroServices it becomes very easier as frontend team managing their own project and Backend team managing their own backend and 
           they are building things parallely.

           -----------------------------                      
           ii. Scalability 
           ----------------------------- 
           In Monolith, in small company or Small project, Scalability is not a challenge in Monolith but as soon as big company or big project then it becomes very tough to 
           scale Monolith architecture bcoz code repositories growing day by day and maintaing that is a mess.

           In MicroServices, there are small small micro services and its easy to manage and scale those services independently.Like having analytics engine and want to scale
           it we can do it independently. Or having frontend micro service or backend micro service so solving the challenges in that small project and scaling it is easier.  

           -----------------------------
           iii. Deployment 
           -----------------------------

           In Monolith, just need to do a single deployment and whole application is deployed. One small change only in Frontend but need to deploy the whole code on to the 
           server and it is time consuming as it takes lot of process and need to go through testing and it becomes tough in Monolith. 

           In MicroServices, need to deploy each and every application seperately. So if any change in Frontend, we can just directly deploy our frontend application and all 
           other micro services work in the same way. But there can be a mismatch in frontend and backend also if they talking to differnet versions.

           -----------------------------
           iv. Tech Stack 
           -----------------------------

           In Monolith, we are restricted with the tech stack coz of one code base, like there is only one tech stack that decided initially like for frontend if it was made
           in React the whole frontend will be in React only. But if backend is in Java stack, then it will be in Java for all services like sending emails, analytics 
           Dashboard, etc.

           In MicroServices, we can built admin Dashboard with React and student Dashboard on Next js. Analytics can be built on GO, backend in Java for sending emails, but 
           backend can be on Node also for a different micro service like Notification. 

           -----------------------------
           v. Infra Cost 
           -----------------------------

           In Monolith, infra is lower as single project is deployed on a server.

           In MicroServices, it is higher as more the services more the infra required. Multiple servers for frontend and backend. seperate micro services need a seperate 
           server. 

           -----------------------------
           vi. Complexity
           -----------------------------

           In Monolith, if Project is large then Complexity is hard to maintain bcoz of single code base, files etc.

           In MicroServices, if Project is small then Complexity is tough bcoz for small project also we managing multiple services for it but if project is large then
           Complexity is easy.

           -----------------------------
           vii. Fault Isolation
           -----------------------------

           In Monolith, if one line of code is faulty or some piece of code breaks in backend then whole project breaks/crashes.

           In MicroServices, it just crashes only that micro service not the whole project. Like issue in analytics then analytics service will go down not whole project. 

           -----------------------------
           viii. Testing
           -----------------------------

           In Monolith, writing end to end test cases will be easier.

           In MicroServices, we can test the services independently and all the services will have their own test cases but writing end to end test cases is tough.

           -----------------------------
           ix. OwnerShip
           -----------------------------

           In Monolith, there is a central ownership and few people decides how deployment and work will be done.

           In MicroServices, differnt teams take the ownership of different MicroServices.

           -----------------------------
           x. Maintainance and Rewamps
           -----------------------------

           In Monolith, it is tough to do that.

           In MicroServices, its easy to maintain like if want to change whole frontend its easier to do that in MicroServices.

           -----------------------------
           xi. Debugging
           -----------------------------

           It can be tough in both bcoz if something breaks then we have to check the fault.

           In  Monolith, its slightly easier bcoz there is one code base and easy to debugg which file or code etc. 

           In MicroServices, there is blame game also as one mico service team blames other. 
           
           -----------------------------
           xiii. Dev Expierence
           -----------------------------

           MicroServices, as i can break my services to smaller services so they cna be independently updated, scale and deployment cycle.